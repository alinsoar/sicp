#lang racket

(require (submod "e.2.56.rkt" export))
(require racket/trace)

;;; simple infix form
(define-unit constructors-simple-infix-form@
  (import)
  (export constructors-algebraic-form^)
  (define (make-sum a1 a2) (list a1 '+ a2 ))
  (define (make-product m1 m2) (list m1 '* m2))
  (define (make-exponentiation m1 m2) (list m1 '* m2)))

(define-unit selectors-simple-infix-form@
  (import)
  (export selectors-algebraic-form^)
  (define addend car)
  (define augend caddr)
  (define multiplier car)
  (define multiplicand caddr)
  (define base car)
  (define exponent caddr))

(define-unit predicates-simple-infix-form@
  (import)
  (export predicates-algebraic-form^)
  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))
  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))
  (define (exponentiation? x)
    (and (pair? x) (eq? (cadr x) '**)))
  )

(module+ test
  (define (test1)
    (define-values/invoke-unit/infer constructors-simple-infix-form@)
    (define-values/invoke-unit/infer selectors-simple-infix-form@)
    (define-values/invoke-unit/infer predicates-simple-infix-form@)
    (define-values/invoke-unit/infer derivation@)
    (list
     (deriv '(x + 3) 'x)
     (deriv '(x * y) 'x)
     (deriv '((x * y) * (x + 3)) 'x)
     (deriv '(x + (3 * (x + (y + 2)))) 'x)))
  (test1))

;;; standard alebraic notation
(define-unit constructors-standard-algebraic-notation-form@
  (import)
  (export constructors-algebraic-form^)
  (define (make-product m1 m2 . rest)
    (define (iter l co)
      (if (null? l)
          (co '())
          (iter (cdr l)
                (lambda (x)
                  (co (cons '* (cons (car l) x)))))))
    (append (list m1 '* m2)
            (iter rest (lambda (x) x))))
  (define (make-exponentiation m1 m2 . rest)
    (define (iter l co)
      (if (null? l)
          (co '())
          (iter (cdr l)
                (lambda (x)
                  (co (cons '** (cons (car l) x)))))))
    (append (list m1 '** m2)
            (iter rest (lambda (x) x))))
  (define (make-sum a1 a2 . rest)
    (define (iter l co)
      (if (null? l)
          (co '())
          (iter (cdr l)
                (lambda (x)
                  (co (cons '+ (cons (car l) x)))))))
    (append (list a1 '+ a2)
            (iter rest (lambda (x) x)))))

(define-unit predicates-standard-algebraic-notation-form@
  (import)
  (export predicates-algebraic-form^)
  (define (exponentiation? x)
    (and (pair? x) (eq? (cadr x) '*)))
  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))
  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+))))

(define-unit selectors-standard-algebraic-notation-form@
  (import)
  (export selectors-algebraic-form^)
  (define (base s) (car s))
  (define (exponent s)
    (if (null? (cdddr s))
        (caddr s)
        (cddr s)))
  (define (addend s) (car s))
  (define (augend s)
    (if (null? (cdddr s))
        (caddr s)
        (cddr s)))
  (define (multiplier p) (car p))
  (define (multiplicand p)
    (if (null? (cdddr p))
        (caddr p)
        (cddr p))))

(module+ test
  (define (test2)
    (define-values/invoke-unit/infer constructors-standard-algebraic-notation-form@)
    (define-values/invoke-unit/infer selectors-standard-algebraic-notation-form@)
    (define-values/invoke-unit/infer predicates-standard-algebraic-notation-form@)
    (define-values/invoke-unit/infer derivation@)
    (list
     (make-sum 'a 'b 'c)
     (addend (make-sum 'a 'b 'c))
     (augend (make-sum 'a 'b 'c))
     (augend (make-sum 'a 'b))
     (make-product 'a 'b 'c (make-sum 'a 'b 'c))
     (multiplier (make-product 'a 'b 'c (make-sum 'a 'b 'c)))
     (multiplicand (make-product 'a 'b 'c (make-sum 'a 'b 'c)))
     (deriv '(x + 3) 'x)
     (deriv '(x * y) 'x)
     (deriv '((x * y) * (x + 3)) 'x)
     (deriv '(x + (3 * (x + (y + 2)))) 'x)
     (deriv '(x + 3 * (x + y + 2)) 'x )))
  (test2))


