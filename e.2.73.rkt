#lang racket

(require "sicp.rkt")

(require (rename-in (submod "e.2.54.rkt" export)
                    (equal2? equal?)))

(define-signature get-op^ (get-operation hash))
(define-signature table-operations^ (put get table-show))
(define-signature derivation^ (deriv))

(define-unit table-operations@
  (import)
  (export table-operations^)
  (define table '())
  (define make-table
    (lambda (message)
      (define (show op) (map op table))
      (define (put op type item)
        (let ((hash (cons op type)))
          (set! table (cons (list hash item) table))))
      (define (get op type)
        (let ((hash (cons op type)))
          (define (assoc h co)
            (cond ((null? h) (co false))
                  ((equal? (caar h) hash) (co (cadar h)))
                  (else (assoc (cdr h)
                               (lambda (x) (co x))))))
          (assoc table (lambda (x) x))))
      (cond ((eq? message 'put) put)
            ((eq? message 'get) get)
            ((eq? message 'show) show)
            (else (error "unknown message")))))
  (define put (lambda (op type item)
                ;; (display (format "put ~a ~a ~a\n" op type item))
                ((make-table 'put) op type item)))
  (define get (lambda (op type)
                ;; (display (format "get ~a ~a\n" op type))
                ((make-table 'get) op type)))
  (define table-show (lambda (op)
                       ((make-table 'show) op))))

(define-unit get-op1@
  (import table-operations^)
  (export get-op^)
  (define get-operation (lambda (x) (get 'deriv x)))
  (define hash (lambda (x y) (cons x y))))
(define-unit get-op2@
  (import table-operations^)
  (export get-op^)
  ;; we switch '(deriv . op) to '(op . deriv) in deriv
  (define get-operation (lambda (x) (get 'deriv x)))
  ;; the only change is to switch the 'hash in 'get -- '(deriv . op)
  ;; will become '(op . deriv).
  (define hash (lambda (x y) (cons y x))))

;;; the numbers and the variables must be treated specially, because
;;; they are objects without visible tags. Inside scheme they are
;;; differentiated, but for user they are not tagged with a fixed tag.
(define-unit derivation@
  (import get-op^ table-operations^)
  (export derivation^)
  (define (deriv exp var)
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (operator exp) (car exp))
    (define (operands exp) (cdr exp))
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get-operation (operator exp))
                 (operands exp)
                 var))))
  (define (install-deriv)
    (define (make-sum a1 a2) (list '+ a1 a2))
    (define (make-product m1 m2) (list '* m1 m2))
    (define (make-exponentiation base exponent) (list '** base exponent))
    (define (deriv-addition exp var)
      (define (addend s) (car s))
      (define (augend s) (cadr s))
      (make-sum (deriv (addend exp) var)
                (deriv (augend exp) var)))
    (define (deriv-multiplication exp var)
      (define (multiplier p) (car p))
      (define (multiplicand p) (cadr p))
      (make-sum (make-product (multiplier exp)
                              (deriv (multiplicand exp) var))
                (make-product (deriv (multiplier exp) var)
                              (multiplicand exp))))
    (define (deriv-exponentiation exp var)
      (define exponent cadr)
      (define base car)
      (make-product (exponent exp)
                    (make-product (make-exponentiation (base exp)
                                                       (make-sum (exponent exp) -1))
                                  (deriv (base exp) var))))
    (put 'deriv '+ deriv-addition)
    (put 'deriv '* deriv-multiplication)
    (put 'deriv '** deriv-exponentiation))
  (install-deriv))

(module+ test
  (define (test1)
    (define-values/invoke-unit/infer table-operations@)
    (define-values/invoke-unit/infer get-op1@)
    (define-values/invoke-unit/infer derivation@)
    (list (deriv '(+ x 3) 'x)
          (deriv '(* x y) 'x)
          (deriv '(* (* x y) (+ x 3)) 'x)
          (deriv '(** (* x x) 2) 'x)
          'ok))
  (define (test2)
    (define-values/invoke-unit/infer table-operations@)
    (define-values/invoke-unit/infer get-op2@)
    (define-values/invoke-unit/infer derivation@)
    (list (deriv '(+ x 3) 'x)
          (deriv '(* x y) 'x)
          (deriv '(* (* x y) (+ x 3)) 'x)
          (deriv '(** (* x x) 2) 'x)
          'ok))
  (list (test1)
        (test2)
        (equal? (test1)
                (test2))
        'ok))

(module+ export
  (define-values/invoke-unit/infer table-operations@)
  (define-values/invoke-unit/infer get-op1@)
  (provide-signature-elements table-operations^)
  (provide table-operations^
           table-operations@))

