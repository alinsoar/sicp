#lang racket

(require "sicp.rkt")
(GETMOD 4 1 without eval apply)

;;;SECTION 4.1.1
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((and? exp) (eval-and exp env))
        ((or? exp) (eval-or exp env))
        ((AND? exp) (eval (expand-AND exp) env))
        ((OR? exp) (eval (expand-OR exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (and? exp) (tagged-list? exp 'and))
(define (or? exp) (tagged-list? exp 'or))

(define (eval-and exp env)
  (define loop
    (lambda (exp)
      (let ((first (car exp))
            (rest (cdr exp)))
        (let ((value (eval first env)))
          (cond ((null? rest) value)
                ((false? value) false)
                (else (loop rest)))))))
  (if (null? (and-clauses exp))
      true
      (loop (and-clauses exp))))
(define and-clauses cdr)

(define (eval-or exp env)
  (define loop
    (lambda (exp)
      (let ((first (car exp))
            (rest (cdr exp)))
        (let ((value (eval first env)))
          (cond ((null? rest) (and value))
                ((true? value) value)
                (else (loop rest)))))))
  (if (null? (and-clauses exp))
      false
      (loop (or-clauses exp))))
(define or-clauses cdr)

(define (AND? exp) (tagged-list? exp 'AND))
(define (OR? exp) (tagged-list? exp 'OR))

(define (expand-AND exp)
  (define (iter e prev co)
    (if (null? e)
        (co prev)
        (iter (cdr e)
              (car e)
              (lambda (x)
                (co (make-if (car e)
                             x
                             'false))))))
  (iter (and-clauses exp)
        'true
        (lambda (x) x)))
(define (expand-OR exp)
  (define (iter e prev co)
    (if (null? e)
        (co prev)
        (iter (cdr e)
              (car e)
              (lambda (x)
                (co (make-if (car e)
                             (car e)
                             x))))))
  (iter (and-clauses exp)
        'false
        (lambda (x) x)))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values-ORIG exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((leftmost-value (eval (first-operand exps) env)))
        (cons leftmost-value (list-of-values (rest-operands exps) env)))))
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
    (eval (definition-value exp) env)
    env)
  'ok)

(module+ test
  (require rackunit)
  (define (test-eval e) (eval e the-global-environment))
  (d "--- and")
  (check-equal? 2 (test-eval '(and 1 2)))
  (check-equal? 2 (test-eval '(and (< 4 5) 2)))
  (check-equal? false (test-eval '(and (< 5 4) 2)))
  (check-equal? false (test-eval '(and true 2 'a false x)))
  (check-pred
   (lambda (m) (d m) (string? m))
   (with-handlers (((lambda (v) (exn? v)) (lambda (v) (exn-message v)))
                   ((lambda (_) true) (lambda (_) (error "SHOULD NOT HAPPEN"))))
     (test-eval '(and true 2 'a true x))))
  (check-equal? 3 (test-eval '(and true 2 'a true 3)))
  (check-equal? true (test-eval '(and true true true)))
  (check-equal? true (test-eval '(and)))
  (d "--- or")
  (check-equal? 1 (test-eval '(or 1 2)))
  (check-equal? true (test-eval '(or (< 4 5) 2)))
  (check-equal? 2 (test-eval '(or (< 5 4) 2)))
  (check-equal? true (test-eval '(or false true 'a 2 false x)))
  (check-equal?
   'no-err
   (with-handlers (((lambda (v) (exn? v)) (lambda (v) (exn-message v)))
                     ((lambda (_) true) (lambda (_) (error "SHOULD NOT HAPPEN"))))
       (test-eval '(or false 'no-err 'a true x))))
  (check-equal? false (test-eval '(or false false (< 4 2))))
  (check-equal? false (test-eval '(or)))
  (d "--- AND expand")
  (expand-AND '(and))
  (expand-AND '(and 1))
  (expand-AND '(and 1 false unknown))
  (expand-AND '(and 1 2 3 4 5 6))
  (d "--- OR expand")
  (expand-OR '(or))
  (expand-OR '(or 1))
  (expand-OR '(or 1 2))
  (expand-OR '(OR false false 3))
  (d "--- AND")
  (check-equal? 2 (test-eval '(AND 1 2)))
  (check-equal? 2 (test-eval '(AND (< 4 5) 2)))
  (check-equal? false (test-eval '(AND (< 5 4) 2)))
  (check-equal? false (test-eval '(AND true 2 'a false x)))
  (check-pred
   (lambda (m) (d m) (string? m))
   (with-handlers (((lambda (v) (exn? v)) (lambda (v) (exn-message v)))
                   ((lambda (_) true) (lambda (_) (error "SHOULD NOT HAPPEN"))))
     (test-eval '(AND true 2 'a true x))))
  (check-equal? 3 (test-eval '(AND true 2 'a true 3)))
  (check-equal? true (test-eval '(AND true true true)))
  (check-equal? true (test-eval '(AND)))
  (test-eval '(AND))
  (test-eval '(AND false))
  (test-eval '(AND true 3))
  (test-eval '(AND true 3 true 4))
  (test-eval '(AND true (< 1 2) true 'ok))
  (test-eval '(AND true false unknown-variable))
  (d "--- OR")
  (check-equal? 1 (test-eval '(OR 1 2)))
  (check-equal? true (test-eval '(OR (< 4 5) 2)))
  (check-equal? 2 (test-eval '(OR (< 5 4) 2)))
  (check-equal? true (test-eval '(OR false true 'a 2 false x)))
  (check-equal?
   'no-err
   (with-handlers (((lambda (v) (exn? v)) (lambda (v) (exn-message v)))
                     ((lambda (_) true) (lambda (_) (error "SHOULD NOT HAPPEN"))))
       (test-eval '(OR false 'no-err 'a true x))))
  (check-equal? false (test-eval '(OR false false (< 4 2))))
  (check-equal? false (test-eval '(OR)))
  'done)

