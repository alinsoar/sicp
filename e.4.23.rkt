#lang racket

(require (prefix-in a: racket/base))
(require "sicp.rkt")
(GETMOD 4 1 without eval)

(define-signature analyze^ (analyze))
(define-signature analyze-sequence^ (analyze-sequence))
(define-signature eval^ (eval))

;;; MAIN ANALYZER
(define-unit eval@
  (import analyze-sequence^)
  (export eval^ analyze^)

  (define (eval exp env)
    ((analyze exp) env))
  (define (analyze exp)
    (cond ((self-evaluating? exp) 
           (analyze-self-evaluating exp))
          ;; ((display? exp) (analyze-display exp))
          ((get-environment? exp) (lambda (env) env))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((application? exp) (analyze-application exp))
          (else
           (error "Unknown expression type -- ANALYZE" exp))))
  (define (analyze-self-evaluating exp)
    (lambda (env) exp))
  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))
  (define (analyze-variable exp)
    (lambda (env) (lookup-variable-value exp env)))
  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      (lambda (env)
        (set-variable-value! var (vproc env) env)
        'ok)))
  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
          (vproc (analyze (definition-value exp))))
      (lambda (env)
        (define-variable! var (vproc env) env)
        'ok)))
  (define (analyze-if exp)
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      (lambda (env)
        (if (true? (pproc env))
            (cproc env)
            (aproc env)))))
  (define (analyze-lambda exp)
    (let ((vars (lambda-parameters exp))
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))
  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
          (aprocs (map analyze (operands exp))))
      (lambda (env)
        (execute-application (fproc env)
                             (map (lambda (aproc) (aproc env))
                                  aprocs)))))
  (define (execute-application proc args)
    (cond ((primitive-procedure? proc)
           (apply-primitive-procedure proc args))
          ((compound-procedure? proc)
           ((procedure-body proc)
            (extend-environment (procedure-parameters proc)
                                args
                                (procedure-environment proc))))
          (else
           (error
            "Unknown procedure type -- EXECUTE-APPLICATION"
            proc)))))

;;; ANALYZE SEQUENCE
(define-unit analyze-sequence@
  (import analyze^)
  (export analyze-sequence^)
  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2 K)
      (d "    :SEQUENTIALLY SYNTAX:" exps)
      (lambda (env)
        (f "\t:P >: [~a] ~a" K exps)
        (proc1 env)
        (f "\t:P *: [~a]" K)
        (let ((v (proc2 env)))
          (f "\t:P <: [~a] ~a" K v)
          v)))
    (define (loop first-proc rest-procs K)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc
                              (car rest-procs)
                              K)
                (cdr rest-procs)
                (+ K 1))))
    (d ":SYNTAX:" exps)
    (let ((procs (map analyze exps)))
      (d ":PROCEDURES:" procs)
      (and (null? procs)
           (error "Empty sequence -- ANALYZE"))
      (loop (car procs) (cdr procs) 0))))
(define-unit analyze-sequence-alyssa@
  (import analyze^)
  (export analyze-sequence^)
  (define (analyze-sequence exps)
    (define (execute-sequence procs env)
      (d "    :SEQUENCE RUNTIME ALYSSA:" exps)
      (cond ((null? (cdr procs))
             (d "P >")
             (let ((v ((car procs) env)))
               (d "P <")
               v))
            (else ((car procs) env)
                  (execute-sequence (cdr procs) env))))
    (d ":SYNTAX ALYSSA:" exps)
    (let ((procs (map analyze exps)))
      (d ":PROCEDURES:" procs)
      (and (null? procs)
           (error "Empty sequence -- ANALYZE"))
      (lambda (env)
        (execute-sequence procs env)))))

;;; EVAL with different ANALYZE SEQUENCES procedures
(define-compound-unit/infer eval/analyze@
  (import)
  (export eval^ analyze-sequence^)
  (link analyze-sequence@ eval@)
  )
(define-compound-unit/infer eval/analyze-alyssa@
  (import)
  (export eval^ analyze-sequence^)
  (link analyze-sequence-alyssa@ eval@)
  )

;; *end* of analyzing evaluator

(module+ test
  (define (code-test evaluator analyze-sequence)
    (define (test-eval e)
      (evaluator e the-global-environment))
    (o "# DEFINE FUN F ") (rp 40 '*) (d)
    (test-eval
     '(define (f x)
        (if (= x 0)
            1
            (* x (f (- x 1))))))
    (test-eval
     '(define (g x)
        (println "G")
        (println x)
        (if (= x 0)
            1
            (* x (g (- x 1))))))
    (o "# CALL F ") (rp 40 '*) (d)
    (test-eval
     '(define (run p a)
        ((lambda (t0)
           (println "result:" (p a))
           (println 'running-time: (- (time) t0)))
         (time))))
    '(test-eval '(run f 10))
    (test-eval '(run g 10)))

  (define (test)
    (define-values/invoke-unit/infer eval/analyze@)
    (code-test eval analyze-sequence))
  (define (test-alyssa)
    (define-values/invoke-unit/infer eval/analyze-alyssa@)
    (code-test eval analyze-sequence))
  (define (m s)
    (rp 15 "~.~" "*") (d)
    (d s)
    (rp 15 "~ ~" "*") (d))
  (m"* FIRST - BUILTIN EACH ELEMENT OF SEQUENCE")
  (test)
  (m"* SECOND - *ALYSSA* - BUILTIN EACH SEQ VIA CONTINUATIONS")
  (test-alyssa)
  'done)

(module+ export
  (provide eval/analyze@
           eval/analyze-alyssa@))
